use std::fmt;
use std::ops::Deref;
use std::pin::Pin;
use std::sync::Arc;

use crate::{PinnedPool, RawPooled};

// NOTE: This implementation closely follows the patterns established by blind_pool::Pooled.
// The blind_pool::Pooled serves as the blueprint for shared reference counting, automatic
// cleanup on last drop, and Arc-based lifetime management.

/// A reference to a value stored in a [`PinnedPool<T>`].
///
/// This type provides automatic lifetime management for values in the pool.
/// When the last [`Pooled<T>`] instance for a value is dropped, the value
/// is automatically removed from the pool.
///
/// Multiple [`Pooled<T>`] instances can reference the same value through
/// cloning, implementing reference counting semantics.
///
/// # Thread Safety
///
/// [`Pooled<T>`] implements thread safety traits conditionally based on the stored type `T`:
///
/// - **Send**: [`Pooled<T>`] is [`Send`] if and only if `T` is [`Sync`]. This allows moving
///   pooled references between threads when the referenced type supports concurrent access.
///
/// - **Sync**: [`Pooled<T>`] is [`Sync`] if and only if `T` is [`Sync`]. This allows sharing
///   the same [`Pooled<T>`] instance between multiple threads when the referenced type supports
///   concurrent access.
///
/// # Example
///
/// ```rust
/// use infinity_pool::PinnedPool;
///
/// let pool = PinnedPool::new();
/// let value_handle = pool.insert("Test".to_string()).into_shared();
///
/// // Access the value through dereferencing.
/// assert_eq!(*value_handle, "Test".to_string());
///
/// // Clone to create additional references.
/// let cloned_handle = value_handle.clone();
/// assert_eq!(*cloned_handle, "Test".to_string());
/// ```
pub struct Pooled<T> {
    /// The reference-counted inner data containing the actual pooled item and pool handle.
    /// This follows the same pattern as blind_pool::Pooled using Arc<PooledInner<T>>.
    inner: Arc<PooledInner<T>>,
}

/// Internal data structure that manages the lifetime of a pooled item.
///
/// This contains both the typed handle and the reference-counted lifetime manager.
/// This follows the same pattern as blind_pool::PooledInner.
struct PooledInner<T> {
    /// The typed handle to the actual item in the pool.
    /// This follows the same pattern as blind_pool::PooledInner.
    handle: RawPooled<T>,
    
    /// A shared reference to the lifetime manager.
    /// This follows the same pattern as blind_pool::PooledInner.
    lifetime: Arc<PooledRef>,
}

/// Internal data structure that ensures cleanup happens exactly once.
///
/// This is always type-erased to `()` and shared among all typed views of the same item.
/// It ensures that the item is removed from the pool exactly once when all references are dropped.
/// This follows the same pattern as blind_pool::PooledRef.
struct PooledRef {
    /// The type-erased handle to the actual item in the pool.
    /// This follows the same pattern as blind_pool::PooledRef.
    handle: RawPooled<()>,
    
    /// A handle to the pool that performs the cleanup operation.
    /// This is type-erased since we only need it for cleanup.
    pool_handle: Arc<dyn PoolCleanup + Send + Sync>,
}

/// Trait for performing cleanup operations on pools.
/// This allows PooledRef to work with any pool type without being generic.
trait PoolCleanup {
    /// Remove a type-erased handle from the pool.
    fn remove_erased(&self, handle: RawPooled<()>);
}

impl<T: Send> PoolCleanup for PinnedPool<T> {
    fn remove_erased(&self, handle: RawPooled<()>) {
        self.remove_raw_handle(handle);
    }
}

impl<T: Send + 'static> PooledInner<T> {
    /// Creates a new `PooledInner` with the given components.
    ///
    /// This follows the same pattern as blind_pool::PooledInner::new().
    #[must_use]
    fn new(handle: RawPooled<T>, pool: PinnedPool<T>) -> Self {
        let lifetime = Arc::new(PooledRef {
            handle: handle.erase(),
            pool_handle: Arc::new(pool),
        });
        Self { handle, lifetime }
    }

    /// Creates a new `PooledInner` sharing the lifetime with an existing one.
    ///
    /// This is used for type casting operations where we want to create a new typed view
    /// while sharing the same lifetime management.
    /// This follows the same pattern as blind_pool::PooledInner::with_shared_lifetime().
    #[must_use]
    fn with_shared_lifetime(handle: RawPooled<T>, lifetime: Arc<PooledRef>) -> Self {
        Self { handle, lifetime }
    }
}

impl<T: Send + 'static> Pooled<T> {
    /// Creates a new pooled value.
    ///
    /// This method is intended for internal use by [`PooledMut::into_shared`] and related methods.
    /// This follows the same pattern as blind_pool::Pooled::new().
    #[must_use]
    pub(crate) fn new(handle: RawPooled<T>, pool: PinnedPool<T>) -> Self {
        let inner = PooledInner::new(handle, pool);
        Self {
            inner: Arc::new(inner),
        }
    }
}

impl<T> Pooled<T> {
    /// Erases the type information from this [`Pooled<T>`] handle,
    /// returning a [`Pooled<()>`].
    ///
    /// This is useful when you want to store handles of different types in the same collection
    /// or pass them to code that doesn't need to know the specific type.
    /// This follows the same pattern as blind_pool::Pooled::erase().
    ///
    /// # Example
    ///
    /// ```rust
    /// use infinity_pool::PinnedPool;
    ///
    /// let pool = PinnedPool::new();
    /// let value_handle = pool.insert("Test".to_string()).into_shared();
    /// let typed_clone = value_handle.clone();
    /// let erased = value_handle.erase();
    ///
    /// // Both handles are valid and refer to the same item.
    /// assert_eq!(*typed_clone, "Test".to_string());
    /// ```
    #[must_use]
    #[inline]
    pub fn erase(self) -> Pooled<()> {
        // Create a new erased handle sharing the same lifetime manager.
        // This follows the same pattern as blind_pool::Pooled::erase().
        let erased_handle = self.inner.handle.erase();
        let erased_inner = PooledInner::with_shared_lifetime(erased_handle, Arc::clone(&self.inner.lifetime));

        Pooled {
            inner: Arc::new(erased_inner),
        }
    }

    /// Returns a pointer to the stored value.
    ///
    /// This provides direct access to the underlying pointer while maintaining the safety
    /// guarantees of the pooled reference. This delegates to the underlying RawPooled.
    /// This follows the same pattern as blind_pool::Pooled::ptr().
    #[must_use]
    #[inline]
    pub fn ptr(&self) -> std::ptr::NonNull<T> {
        self.inner.handle.ptr()
    }

    /// Returns a pinned reference to the value stored in the pool.
    ///
    /// Since values in the pool are always pinned (they never move once inserted),
    /// this method provides safe access to `Pin<&T>` without requiring unsafe code.
    /// This delegates to the underlying RawPooled, following established patterns.
    ///
    /// # Example
    ///
    /// ```rust
    /// use std::pin::Pin;
    /// use infinity_pool::PinnedPool;
    ///
    /// let pool = PinnedPool::new();
    /// let handle = pool.insert("hello".to_string()).into_shared();
    ///
    /// let pinned: Pin<&String> = handle.as_pin();
    /// assert_eq!(pinned.len(), 5);
    /// ```
    #[must_use]
    #[inline]
    pub fn as_pin(&self) -> Pin<&T> {
        // Delegate to the underlying RawPooled as_pin implementation.
        // This follows the same pattern as blind_pool::Pooled.
        self.inner.handle.as_pin()
    }
}

impl<T> Clone for Pooled<T> {
    /// Creates another handle to the same pooled value.
    ///
    /// This increases the reference count for the underlying value. The value will only be
    /// removed from the pool when all cloned handles are dropped.
    /// This follows the same pattern as blind_pool::Pooled::clone().
    ///
    /// # Example
    ///
    /// ```rust
    /// use infinity_pool::PinnedPool;
    ///
    /// let pool = PinnedPool::new();
    /// let value_handle = pool.insert("Test".to_string()).into_shared();
    ///
    /// let cloned_handle = value_handle.clone();
    ///
    /// // Both handles refer to the same value.
    /// assert_eq!(*value_handle, *cloned_handle);
    /// ```
    #[inline]
    fn clone(&self) -> Self {
        Self {
            inner: Arc::clone(&self.inner),
        }
    }
}

impl<T> Deref for Pooled<T> {
    type Target = T;

    /// Provides direct access to the value stored in the pool.
    ///
    /// This allows the handle to be used as if it were a reference to the stored value.
    /// This delegates to the underlying RawPooled, following established patterns.
    #[inline]
    fn deref(&self) -> &Self::Target {
        // Delegate to the underlying RawPooled Deref implementation.
        // This follows the same pattern as blind_pool::Pooled.
        &self.inner.handle
    }
}

impl Drop for PooledRef {
    /// Automatically removes the item from the pool when the last reference is dropped.
    ///
    /// This ensures that resources are properly cleaned up without requiring manual intervention.
    /// This follows the same pattern as blind_pool::PooledRef::drop().
    #[inline]
    fn drop(&mut self) {
        // We are guaranteed to be the only one executing this drop because Arc ensures
        // that Drop on the PooledRef is only called once when the last reference is released.
        // SAFETY: This pooled handle is being consumed by Drop, ensuring it cannot be used again.
        
        // SAFETY: We are in Drop, so we can safely read the handle field.
        let handle: RawPooled<()> = unsafe { std::ptr::read(&self.handle) };
        self.pool_handle.remove_erased(handle);
    }
}

// SAFETY: Pooled<T> can be Send if T is Sync, because multiple threads could
// access the same referenced data when the Pooled<T> is moved between threads.
// This follows the same pattern as blind_pool::Pooled.
unsafe impl<T: Sync> Send for Pooled<T> {}

// SAFETY: Pooled<T> can be Sync if T is Sync, because multiple threads can safely
// access the same Pooled<T> instance if T is Sync. The deref operation is safe
// for concurrent access when T is Sync.
// This follows the same pattern as blind_pool::Pooled.
unsafe impl<T: Sync> Sync for Pooled<T> {}

impl<T> fmt::Debug for Pooled<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Pooled")
            .field("type_name", &std::any::type_name::<T>())
            .field("ptr", &self.inner.handle.ptr())
            .finish()
    }
}

impl<T> fmt::Debug for PooledInner<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PooledInner")
            .field("type_name", &std::any::type_name::<T>())
            .field("ptr", &self.handle.ptr())
            .field("lifetime", &"<lifetime>")
            .finish()
    }
}

impl fmt::Debug for PooledRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PooledRef")
            .field("handle", &self.handle)
            .field("pool_handle", &"<pool>")
            .finish()
    }
}

// SAFETY: PooledRef can be Send because both RawPooled<()> and the trait object are Send.
// This follows the same pattern as blind_pool::PooledRef.
unsafe impl Send for PooledRef {}

// SAFETY: PooledRef can be Sync because both RawPooled<()> and the trait object are Sync.
// This follows the same pattern as blind_pool::PooledRef.
unsafe impl Sync for PooledRef {}

// SAFETY: PooledInner<T> can be Send if T is Sync, following the same reasoning as Pooled<T>.
// This follows the same pattern as blind_pool::PooledInner.
unsafe impl<T: Sync> Send for PooledInner<T> {}

// SAFETY: PooledInner<T> can be Sync if T is Sync, following the same reasoning as Pooled<T>.
// This follows the same pattern as blind_pool::PooledInner.
unsafe impl<T: Sync> Sync for PooledInner<T> {}