use std::sync::{Arc, Mutex};

use crate::{PinnedPoolOptions, PooledMut, RawPinnedPool, RawPooled};

// NOTE: This implementation follows the patterns established by BlindPool and RawPinnedPool.
// BlindPool serves as the blueprint for Arc+Mutex pooling patterns with automatic cleanup.
// RawPinnedPool provides the underlying type-safe pool functionality that we delegate to.

/// A thread-safe pool of `T` with automatic lifetime management.
/// 
/// Objects placed inside the pool are automatically removed from the pool when the last
/// `Pooled<T>` or `PooledMut<T>` referencing them is dropped, similar to `Arc<T>`.
/// 
/// The pool itself is a shallow-cloneable handle - all clones share the same underlying
/// capacity and are functionally identical.
///
/// # Thread Safety
///
/// `PinnedPool<T>` is thread-safe (both `Send` and `Sync`). Objects in the pool are required
/// to be `Send`.
///
/// # Example
///
/// ```rust
/// use infinity_pool::PinnedPool;
///
/// let pool = PinnedPool::new();
/// let cloned_pool = pool.clone(); // Same underlying capacity
///
/// let handle = pool.insert("Hello".to_string());
/// assert_eq!(*handle, "Hello");
/// 
/// // Item automatically removed when handle is dropped
/// ```
#[derive(Debug)]
pub struct PinnedPool<T: Send> {
    /// The underlying raw pool protected by a mutex for thread-safe access.
    inner: Arc<Mutex<RawPinnedPool<T>>>,
}

impl<T: Send> PinnedPool<T> {
    /// Creates a new empty pool with default options.
    #[must_use]
    pub fn new() -> Self {
        Self {
            inner: Arc::new(Mutex::new(RawPinnedPool::new())),
        }
    }

    /// Creates a new pool with the specified options.
    #[must_use]
    pub fn with_options(options: PinnedPoolOptions) -> Self {
        Self {
            inner: Arc::new(Mutex::new(RawPinnedPool::with_options(options))),
        }
    }

    /// Returns the number of objects currently stored in the pool.
    #[must_use]
    pub fn len(&self) -> usize {
        self.inner.lock().expect("Pool mutex poisoned").len()
    }

    /// Returns the current capacity of the pool (the number of objects it can hold without reallocation).
    #[must_use]
    pub fn capacity(&self) -> usize {
        self.inner.lock().expect("Pool mutex poisoned").capacity()
    }

    /// Returns `true` if the pool contains no objects.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.inner.lock().expect("Pool mutex poisoned").is_empty()
    }

    /// Reserves capacity for at least `additional` more objects.
    pub fn reserve(&self, additional: usize) {
        self.inner
            .lock()
            .expect("Pool mutex poisoned")
            .reserve(additional);
    }

    /// Reduces memory usage by releasing unused capacity.
    pub fn shrink_to_fit(&self) {
        self.inner
            .lock()
            .expect("Pool mutex poisoned")
            .shrink_to_fit();
    }

    /// Inserts a value into the pool and returns a handle to it.
    ///
    /// The returned handle provides automatic lifetime management - the value
    /// will be removed from the pool when the handle is dropped.
    ///
    /// # Example
    ///
    /// ```rust
    /// use infinity_pool::PinnedPool;
    ///
    /// let pool = PinnedPool::new();
    /// let handle = pool.insert("Hello".to_string());
    /// assert_eq!(*handle, "Hello");
    /// // Value automatically removed when handle is dropped
    /// ```
    pub fn insert(&self, value: T) -> PooledMut<T> {
        let raw_handle = {
            let mut guard = self.inner.lock().expect("Pool mutex poisoned");
            guard.insert(value)
        };
        PooledMut::new(raw_handle, self.clone())
    }

    /// Internal method for removing items from the pool.
    ///
    /// # Safety
    ///
    /// The handle must be valid and owned by the caller.
    pub(crate) fn remove_raw_handle(&self, handle: RawPooled<()>) {
        let mut guard = self.inner.lock().expect("Pool mutex poisoned");
        // SAFETY: The handle is valid and owned by the calling pooled wrapper.
        unsafe {
            guard.remove(handle);
        }
    }

    /// Internal method for removing and returning an Unpin value from the pool.
    ///
    /// # Safety
    ///
    /// The handle must be valid and owned by the caller, and P must be Unpin.
    pub(crate) fn remove_unpin_raw_handle<P: Unpin>(&self, handle: RawPooled<P>) -> P {
        let mut guard = self.inner.lock().expect("Pool mutex poisoned");
        // SAFETY: The handle is valid and owned by the calling pooled wrapper, and P: Unpin.
        unsafe {
            guard.remove_unpin(handle)
        }
    }
}

impl<T: Send> Clone for PinnedPool<T> {
    /// Creates a new handle that shares the same underlying pool capacity.
    ///
    /// All cloned instances reference the same pool, so changes made through one
    /// instance will be visible through all other cloned instances.
    fn clone(&self) -> Self {
        Self {
            inner: Arc::clone(&self.inner),
        }
    }
}

impl<T: Send> Default for PinnedPool<T> {
    /// Creates a new empty pool with default options.
    ///
    /// This is equivalent to calling `PinnedPool::new()`.
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Pooled, PooledMut};
    use static_assertions::{assert_impl_all, assert_not_impl_any};

    #[test]
    fn basic_insertion_and_access() {
        let pool = PinnedPool::new();
        
        // Test basic insertion
        let handle = pool.insert("Hello".to_string());
        assert_eq!(*handle, "Hello");
        assert_eq!(pool.len(), 1);
        assert!(!pool.is_empty());
        
        // Value should be removed when handle is dropped
        drop(handle);
        assert_eq!(pool.len(), 0);
        assert!(pool.is_empty());
    }

    #[test]
    fn cloning_pool_shares_capacity() {
        let pool1 = PinnedPool::new();
        let pool2 = pool1.clone();
        
        // Insert into pool1
        let handle1 = pool1.insert(42_i32);
        
        // Both pools should see the same item
        assert_eq!(pool1.len(), 1);
        assert_eq!(pool2.len(), 1);
        
        // Insert into pool2
        let handle2 = pool2.insert(84_i32);
        
        // Both pools should see both items
        assert_eq!(pool1.len(), 2);
        assert_eq!(pool2.len(), 2);
        
        // Access the values
        assert_eq!(*handle1, 42);
        assert_eq!(*handle2, 84);
        
        // Clean up
        drop(handle1);
        assert_eq!(pool1.len(), 1);
        assert_eq!(pool2.len(), 1);
        
        drop(handle2);
        assert_eq!(pool1.len(), 0);
        assert_eq!(pool2.len(), 0);
    }

    #[test]
    fn mutable_access_and_modification() {
        let pool = PinnedPool::new();
        let mut handle = pool.insert(vec![1, 2, 3]);
        
        // Test mutable access
        handle.push(4);
        assert_eq!(*handle, vec![1, 2, 3, 4]);
        
        // Test that changes persist
        assert_eq!(handle.len(), 4);
    }

    #[test] 
    fn into_shared_conversion() {
        let pool = PinnedPool::new();
        let mut exclusive = pool.insert("Test".to_string());
        
        // Modify while exclusive
        exclusive.push_str(" - Modified");
        assert_eq!(*exclusive, "Test - Modified");
        assert_eq!(pool.len(), 1);
        
        // Convert to shared
        let shared = exclusive.into_shared();
        assert_eq!(*shared, "Test - Modified");
        assert_eq!(pool.len(), 1);
        
        // Clone shared handle
        let cloned = shared.clone();
        assert_eq!(*cloned, "Test - Modified");
        assert_eq!(pool.len(), 1); // Still just one item
        
        // Verify both handles work
        assert_eq!(*shared, *cloned);
        
        // Drop original shared handle
        drop(shared);
        assert_eq!(pool.len(), 1); // Still alive due to clone
        assert_eq!(*cloned, "Test - Modified"); // Still accessible
        
        // Drop final handle
        drop(cloned);
        assert_eq!(pool.len(), 0); // Now cleaned up
    }

    #[test]
    fn into_inner_extraction() {
        let pool = PinnedPool::new();
        let mut handle = pool.insert("Hello".to_string());
        
        handle.push_str(" World");
        assert_eq!(*handle, "Hello World");
        assert_eq!(pool.len(), 1);
        
        // Extract the value
        let extracted = handle.into_inner();
        assert_eq!(extracted, "Hello World");
        assert_eq!(pool.len(), 0); // Pool should be empty now
        
        // Verify extracted value is fully owned
        let mut owned = extracted;
        owned.push_str(" - Owned");
        assert_eq!(owned, "Hello World - Owned");
    }

    #[test] 
    fn erase_type_information() {
        let pool = PinnedPool::new();
        let handle = pool.insert("Test".to_string()).into_shared();
        let typed_clone = handle.clone();
        
        // Erase type information
        let erased = handle.erase();
        
        // Verify typed handle still works
        assert_eq!(*typed_clone, "Test");
        assert_eq!(pool.len(), 1);
        
        // Both handles should keep the item alive
        drop(erased);
        assert_eq!(pool.len(), 1);
        assert_eq!(*typed_clone, "Test");
        
        drop(typed_clone);
        assert_eq!(pool.len(), 0);
    }

    #[test]
    fn pinning_functionality() {
        let pool = PinnedPool::new();
        let mut handle = pool.insert("Pin test".to_string());
        
        // Test as_pin() method
        let pinned_ref = handle.as_pin();
        assert_eq!(&**pinned_ref, "Pin test");
        
        // Test as_pin_mut() method
        let pinned_mut = handle.as_pin_mut();
        pinned_mut.get_mut().push_str(" - modified");
        
        // Verify the mutation worked
        assert_eq!(&*handle, "Pin test - modified");
    }

    #[test]
    fn capacity_management() {
        let pool = PinnedPool::new();
        
        // Initial state
        assert_eq!(pool.len(), 0);
        assert!(pool.is_empty());
        let initial_capacity = pool.capacity();
        
        // Reserve capacity
        pool.reserve(10);
        assert!(pool.capacity() >= initial_capacity + 10);
        
        // Add some items
        let _handle1 = pool.insert(1_u32);
        let _handle2 = pool.insert(2_u32);
        assert_eq!(pool.len(), 2);
        assert!(!pool.is_empty());
        
        // Shrink to fit (this might or might not change capacity)
        pool.shrink_to_fit();
        assert_eq!(pool.len(), 2); // Length should be unchanged
    }

    #[test]
    fn with_options_constructor() {
        use crate::DropPolicy;
        
        let options = PinnedPoolOptions {
            drop_policy: DropPolicy::MustNotDropItems,
        };
        
        let pool = PinnedPool::with_options(options);
        let handle = pool.insert(42_i32);
        
        assert_eq!(*handle, 42);
        assert_eq!(pool.len(), 1);
    }

    #[test]
    fn multiple_types_in_different_pools() {
        let string_pool = PinnedPool::new();
        let int_pool = PinnedPool::new();
        
        let string_handle = string_pool.insert("Hello".to_string());
        let int_handle = int_pool.insert(42_i32);
        
        assert_eq!(*string_handle, "Hello");
        assert_eq!(*int_handle, 42);
        
        assert_eq!(string_pool.len(), 1);
        assert_eq!(int_pool.len(), 1);
    }

    #[test]
    fn works_with_drop_types() {
        use std::sync::Arc;
        use std::sync::atomic::{AtomicBool, Ordering};

        struct DropTracker {
            dropped: Arc<AtomicBool>,
        }

        impl Drop for DropTracker {
            fn drop(&mut self) {
                self.dropped.store(true, Ordering::Relaxed);
            }
        }

        let pool = PinnedPool::new();
        let dropped = Arc::new(AtomicBool::new(false));

        {
            let _handle = pool.insert(DropTracker {
                dropped: Arc::clone(&dropped),
            });
            assert!(!dropped.load(Ordering::Relaxed));
        }

        // Item's Drop should have been called when pool handle was dropped
        assert!(dropped.load(Ordering::Relaxed));
    }

    #[test]
    fn thread_safety_assertions() {
        // PinnedPool<T> should be Send and Sync
        assert_impl_all!(PinnedPool<u32>: Send, Sync);
        assert_impl_all!(PinnedPool<String>: Send, Sync);
        
        // PooledMut<T> should be Send if T is Send, but never Sync
        assert_impl_all!(PooledMut<u32>: Send);
        assert_impl_all!(PooledMut<String>: Send);
        assert_not_impl_any!(PooledMut<u32>: Sync);
        assert_not_impl_any!(PooledMut<String>: Sync);
        
        // Pooled<T> should be Send and Sync if T is Sync
        assert_impl_all!(Pooled<u32>: Send, Sync);
        assert_impl_all!(Pooled<String>: Send, Sync);
        
        // With non-Sync types, Pooled should not be Send or Sync
        use std::cell::RefCell;
        assert_not_impl_any!(Pooled<RefCell<u32>>: Send, Sync);
    }

    #[test]
    fn clone_trait_implementation() {
        let pool = PinnedPool::new();
        let cloned = pool.clone();
        
        // Verify they share the same underlying capacity
        let handle1 = pool.insert(1_u32);
        assert_eq!(cloned.len(), 1);
        
        let handle2 = cloned.insert(2_u32); 
        assert_eq!(pool.len(), 2);
        
        assert_eq!(*handle1, 1);
        assert_eq!(*handle2, 2);
    }

    #[test]
    fn default_trait_implementation() {
        let pool: PinnedPool<String> = PinnedPool::default();
        assert_eq!(pool.len(), 0);
        assert!(pool.is_empty());
        
        let handle = pool.insert("Default".to_string());
        assert_eq!(*handle, "Default");
    }
}
