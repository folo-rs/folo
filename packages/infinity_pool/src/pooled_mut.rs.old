use std::fmt;
use std::ops::{Deref, DerefMut};
use std::pin::Pin;

use crate::{PinnedPool, Pooled, RawPooledMut};

// NOTE: This implementation closely follows the patterns established by blind_pool::PooledMut.
// The blind_pool::PooledMut serves as the blueprint for RAII pool handle behavior,
// automatic cleanup on drop, and conversion to shared handles.

/// A mutable reference to a value stored in a [`PinnedPool<T>`].
///
/// This type provides automatic lifetime management for values in the pool with exclusive access.
/// When the [`PooledMut<T>`] instance is dropped, the value is automatically removed from the pool.
///
/// Unlike [`Pooled<T>`], this type does not implement [`Clone`] and provides exclusive access
/// through [`DerefMut`], making it suitable for scenarios where mutable access is required
/// and shared ownership is not needed.
///
/// # Thread Safety
///
/// [`PooledMut<T>`] implements thread safety traits conditionally based on the stored type `T`:
///
/// - **Send**: [`PooledMut<T>`] is [`Send`] if and only if `T` is [`Send`]. This allows moving
///   pooled mutable references between threads when the referenced type can be moved between threads.
///
/// - **Sync**: [`PooledMut<T>`] does NOT implement [`Sync`] because it provides exclusive mutable
///   access via [`DerefMut`]. Allowing multiple threads to share references to the same
///   [`PooledMut<T>`] instance would violate Rust's borrowing rules and lead to data races.
///
/// # Example
///
/// ```rust
/// use infinity_pool::PinnedPool;
///
/// let pool = PinnedPool::new();
/// let mut value_handle = pool.insert("Test".to_string());
///
/// // Mutably access the value.
/// value_handle.push_str(" - Modified");
/// assert_eq!(*value_handle, "Test - Modified");
///
/// // Value is automatically cleaned up when handle is dropped.
/// ```
pub struct PooledMut<T: Send> {
    /// The raw handle to the pooled item.
    /// This follows the same pattern as blind_pool::PooledMut using a raw handle.
    handle: RawPooledMut<T>,
    
    /// A reference to the pool to perform cleanup operations.
    /// This follows the same pattern as blind_pool::PooledMut maintaining pool reference.
    pool: PinnedPool<T>,
}

impl<T: Send> PooledMut<T> {
    /// Creates a new [`PooledMut<T>`] from a raw handle and pool reference.
    ///
    /// This is an internal constructor used by [`PinnedPool::insert`] and related methods.
    /// This follows the same pattern as blind_pool::PooledMut::new().
    #[must_use]
    pub(crate) fn new(handle: RawPooledMut<T>, pool: PinnedPool<T>) -> Self {
        Self { handle, pool }
    }

    /// Returns a pinned reference to the value stored in the pool.
    ///
    /// Since values in the pool are always pinned (they never move once inserted),
    /// this method provides safe access to `Pin<&T>` without requiring unsafe code.
    /// This delegates to the underlying RawPooledMut, following established patterns.
    ///
    /// # Example
    ///
    /// ```rust
    /// use std::pin::Pin;
    /// use infinity_pool::PinnedPool;
    ///
    /// let pool = PinnedPool::new();
    /// let handle = pool.insert("hello".to_string());
    ///
    /// let pinned: Pin<&String> = handle.as_pin();
    /// assert_eq!(pinned.len(), 5);
    /// ```
    #[must_use]
    #[inline]
    pub fn as_pin(&self) -> Pin<&T> {
        // Delegate to the underlying RawPooledMut as_pin implementation.
        // This follows the same pattern as blind_pool::PooledMut.
        self.handle.as_pin()
    }

    /// Returns a pinned mutable reference to the value stored in the pool.
    ///
    /// Since values in the pool are always pinned (they never move once inserted),
    /// this method provides safe access to `Pin<&mut T>` without requiring unsafe code.
    /// This delegates to the underlying RawPooledMut, following established patterns.
    ///
    /// # Example
    ///
    /// ```rust
    /// use std::pin::Pin;
    /// use infinity_pool::PinnedPool;
    ///
    /// let pool = PinnedPool::new();
    /// let mut handle = pool.insert("hello".to_string());
    ///
    /// let mut pinned: Pin<&mut String> = handle.as_pin_mut();
    /// // Can use Pin methods or deref to &mut String
    /// ```
    #[must_use]
    #[inline]
    pub fn as_pin_mut(&mut self) -> Pin<&mut T> {
        // Delegate to the underlying RawPooledMut as_pin_mut implementation.
        // This follows the same pattern as blind_pool::PooledMut.
        self.handle.as_pin_mut()
    }

    /// Converts this exclusive [`PooledMut<T>`] handle into a shared [`Pooled<T>`] handle.
    ///
    /// This operation consumes the [`PooledMut<T>`] and returns a [`Pooled<T>`] that allows
    /// multiple shared references to the same pooled value. Once converted, you can no longer
    /// obtain exclusive (mutable) references to the value, but you can create multiple
    /// shared references through cloning.
    ///
    /// The returned [`Pooled<T>`] maintains the same lifetime management semantics -
    /// the value will be automatically removed from the pool when all references are dropped.
    /// This follows the same pattern as blind_pool::PooledMut::into_shared().
    ///
    /// # Example
    ///
    /// ```rust
    /// use infinity_pool::PinnedPool;
    ///
    /// let pool = PinnedPool::new();
    /// let mut exclusive_handle = pool.insert("Test".to_string());
    ///
    /// // Modify the value while we have exclusive access.
    /// exclusive_handle.push_str(" - Modified");
    /// assert_eq!(*exclusive_handle, "Test - Modified");
    ///
    /// // Convert to shared access.
    /// let shared_handle = exclusive_handle.into_shared();
    ///
    /// // Now we can create multiple shared references.
    /// let cloned_handle = shared_handle.clone();
    /// assert_eq!(*shared_handle, "Test - Modified");
    /// assert_eq!(*cloned_handle, "Test - Modified");
    /// ```
    #[must_use]
    #[inline]
    pub fn into_shared(self) -> Pooled<T> 
    where
        T: Send + 'static,
    {
        // Prevent the Drop from running on this handle since we're transferring ownership.
        // This follows the same pattern as blind_pool::PooledMut::into_shared().
        let this = std::mem::ManuallyDrop::new(self);
        
        // SAFETY: We are reading from ManuallyDrop wrapped value to transfer ownership.
        // The fields are guaranteed to be initialized and we prevent Drop from running.
        let handle = unsafe { std::ptr::read(&raw const this.handle) };
        let pool = unsafe { std::ptr::read(&raw const this.pool) };

        // Convert the exclusive handle to a shared handle and create the shared pooled type.
        // This delegates to RawPooledMut::into_shared() following established patterns.
        let shared_handle = handle.into_shared();
        Pooled::new(shared_handle, pool)
    }
}

impl<T: Send + Unpin> PooledMut<T> {
    /// Moves the value out of the pool, returning it to the caller and consuming the [`PooledMut<T>`].
    ///
    /// This method extracts the value from the pool and transfers ownership to the caller.
    /// The item is removed from the pool, but the value is not dropped - instead, it is
    /// returned to the caller who becomes responsible for its lifetime management.
    ///
    /// This method is only available for types that implement [`Unpin`], as moving a value
    /// out of the pool would break the pinning guarantee for `!Unpin` types.
    /// This follows the same pattern as blind_pool::PooledMut::into_inner().
    ///
    /// # Example
    ///
    /// ```rust
    /// use infinity_pool::PinnedPool;
    ///
    /// let pool = PinnedPool::new();
    /// let mut pooled_string = pool.insert("Hello".to_string());
    ///
    /// // Modify the value while it is in the pool.
    /// pooled_string.push_str(" World");
    /// assert_eq!(*pooled_string, "Hello World");
    /// assert_eq!(pool.len(), 1);
    ///
    /// // Extract the value from the pool.
    /// let extracted_string = pooled_string.into_inner();
    /// assert_eq!(extracted_string, "Hello World");
    /// assert_eq!(pool.len(), 0); // Pool is now empty.
    /// ```
    #[must_use]
    #[inline]
    pub fn into_inner(self) -> T {
        // Prevent the Drop from running on this handle since we're extracting the value.
        // This follows the same pattern as blind_pool::PooledMut::into_inner().
        let this = std::mem::ManuallyDrop::new(self);
        
        // SAFETY: We are reading from ManuallyDrop wrapped value to access fields.
        // The fields are guaranteed to be initialized and we prevent Drop from running.
        let handle = unsafe { std::ptr::read(&raw const this.handle) };
        let pool = unsafe { std::ptr::read(&raw const this.pool) };

        // Remove the item from the pool and return the value.
        // This delegates to the pool's remove_unpin method, following established patterns.
        // SAFETY: T: Unpin is guaranteed by the impl constraint, and this handle
        // is consumed by this operation, ensuring it cannot be used again.
        pool.remove_unpin_raw_handle(handle.into_shared())
    }
}

impl<T: Send> Deref for PooledMut<T> {
    type Target = T;

    /// Provides direct access to the value stored in the pool.
    ///
    /// This allows the handle to be used as if it were a reference to the stored value.
    /// This delegates to the underlying RawPooledMut, following established patterns.
    #[inline]
    fn deref(&self) -> &Self::Target {
        // Delegate to the underlying RawPooledMut Deref implementation.
        // This follows the same pattern as blind_pool::PooledMut.
        &self.handle
    }
}

impl<T: Send> DerefMut for PooledMut<T> {
    /// Provides direct mutable access to the value stored in the pool.
    ///
    /// This allows the handle to be used as if it were a mutable reference to the stored value.
    /// This delegates to the underlying RawPooledMut, following established patterns.
    #[inline]
    fn deref_mut(&mut self) -> &mut Self::Target {
        // Delegate to the underlying RawPooledMut DerefMut implementation.
        // This follows the same pattern as blind_pool::PooledMut.
        &mut self.handle
    }
}

impl<T: Send> Drop for PooledMut<T> {
    /// Automatically removes the item from the pool when the handle is dropped.
    ///
    /// This ensures that resources are properly cleaned up without requiring manual intervention.
    /// This follows the same pattern as blind_pool::PooledMut::drop().
    #[inline]
    fn drop(&mut self) {
        // Remove the item from the pool using the shared handle conversion and type erasure.
        // This follows the same pattern as blind_pool::PooledMut, but we need to work around 
        // Rust's borrow checker since we need to move fields out of &mut self.
        
        // SAFETY: We are in Drop, so we can safely read the fields and take ownership.
        // The struct will not be used after Drop completes.
        let handle: RawPooledMut<T> = unsafe { std::ptr::read(&self.handle) };
        
        // Create a shared handle and remove from pool
        // SAFETY: This handle is being consumed by Drop, ensuring it cannot be used again.
        let shared_handle = handle.into_shared().erase();
        self.pool.remove_raw_handle(shared_handle);
    }
}

// SAFETY: PooledMut<T> can be Send if T is Send, because we can move the exclusive
// mutable access between threads when T can be moved between threads.
// This follows the same pattern as blind_pool::PooledMut.
unsafe impl<T: Send> Send for PooledMut<T> {}

// Note: PooledMut<T> does NOT implement Sync because it provides mutable access
// via DerefMut. Allowing multiple threads to share references to the same
// PooledMut<T> instance would violate Rust's borrowing rules and lead to data races.
// This follows the same pattern as blind_pool::PooledMut.

impl<T: Send> fmt::Debug for PooledMut<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PooledMut")
            .field("type_name", &std::any::type_name::<T>())
            .field("ptr", &self.handle.ptr())
            .finish()
    }
}