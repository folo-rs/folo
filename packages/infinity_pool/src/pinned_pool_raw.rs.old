use std::alloc::Layout;
use std::cell::Cell;
use std::marker::PhantomData;
use std::mem::MaybeUninit;

use crate::{DropPolicy, RawOpaquePool, RawPooled, RawPooledMut};

// NOTE: This implementation is designed to stay synchronized with the Pool implementation.
// When Pool is updated, this type should be updated accordingly to maintain API alignment.
// The Pool struct in pool.rs serves as the template for this implementation.

/// Configuration options for creating a `RawPinnedPool`.
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
#[non_exhaustive]
pub struct PinnedPoolOptions {
    /// Drop policy that determines how the pool handles remaining items when dropped.
    pub drop_policy: DropPolicy,
}

/// A pool of objects of a specific type `T`.
///
/// Methods that take handles can accept type-erased handles via the generic `P` parameter to support
/// removal through handles that may not match the pool's type `T`.
///
/// # Thread Safety
///
/// This type is `Send` but not `Sync`. It can be moved between threads but cannot be shared
/// between threads without explicit synchronization. The contained objects must also be `Send`
/// for the pool to be `Send`.
#[derive(Debug)]
pub struct RawPinnedPool<T> {
    /// The underlying pool that manages memory and storage.
    pool: RawOpaquePool,
    
    /// Phantom data to associate the pool with type T.
    _marker: PhantomData<T>,
    
    /// Ensures the pool is not Sync (cannot be shared between threads).
    _not_sync: PhantomData<Cell<()>>,
}

impl<T> RawPinnedPool<T> {
    /// Creates a new pool for objects of type `T` with default options.
    ///
    /// # Panics
    ///
    /// Panics if the type `T` has zero size.
    #[must_use]
    pub fn new() -> Self {
        Self::with_options(PinnedPoolOptions::default())
    }

    /// Creates a new pool for objects of type `T` with the specified options.
    ///
    /// # Panics
    ///
    /// Panics if the type `T` has zero size.
    #[must_use]
    pub fn with_options(options: PinnedPoolOptions) -> Self {
        let pool = RawOpaquePool::new(Layout::new::<T>(), options.drop_policy);
        
        Self {
            pool,
            _marker: PhantomData,
            _not_sync: PhantomData,
        }
    }

    /// Returns the number of objects currently in the pool.
    #[cfg_attr(test, mutants::skip)] // Can be mutated to infinitely growing memory use and/or infinite loop.
    #[must_use]
    pub fn len(&self) -> usize {
        self.pool.len()
    }

    /// Returns the total capacity of the pool.
    #[cfg_attr(test, mutants::skip)] // Can be mutated to infinitely growing memory use and/or infinite loop.
    #[must_use]
    pub fn capacity(&self) -> usize {
        self.pool.capacity()
    }

    /// Returns `true` if the pool contains no objects.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.pool.is_empty()
    }

    /// Reserves capacity for at least `additional` more objects.
    pub fn reserve(&mut self, additional: usize) {
        self.pool.reserve(additional);
    }

    /// Reduces memory usage by releasing unused capacity.
    pub fn shrink_to_fit(&mut self) {
        self.pool.shrink_to_fit();
    }

    /// Inserts an object into the pool and returns a handle to it.
    pub fn insert(&mut self, value: T) -> RawPooledMut<T> {
        // SAFETY: T matches the pool's layout by construction.
        unsafe { self.pool.insert(value) }
    }

    /// Inserts an object into the pool via closure and returns a handle to it.
    ///
    /// The closure `f` will be called with a reference to uninitialized memory for type `T`.
    /// The closure must properly initialize the memory before returning.
    pub fn insert_with<F>(&mut self, f: F) -> RawPooledMut<T>
    where
        F: FnOnce(&mut MaybeUninit<T>),
    {
        // SAFETY: T matches the pool's layout by construction.
        unsafe { self.pool.insert_with(f) }
    }

    /// Removes an object from the pool, dropping it.
    ///
    /// # Panics
    ///
    /// Panics if the handle does not reference an existing item in this pool.
    pub fn remove_mut<P: ?Sized>(&mut self, handle: RawPooledMut<P>) {
        self.pool.remove_mut(handle);
    }

    /// Removes an object from the pool, dropping it.
    ///
    /// # Panics
    ///
    /// Panics if the handle does not reference an existing item in this pool.
    ///
    /// # Safety
    ///
    /// The caller must ensure that the handle is valid and belongs to this pool.
    pub unsafe fn remove<P: ?Sized>(&mut self, handle: RawPooled<P>) {
        // SAFETY: Forwarding guarantees from caller.
        unsafe {
            self.pool.remove(handle);
        }
    }

    /// Removes an object from the pool and returns it.
    ///
    /// # Panics
    ///
    /// Panics if the handle does not reference an existing item in this pool.
    ///
    /// Panics if `P` is a type-erased handle (`RawPooledMut<()>`).
    pub fn remove_mut_unpin<P: Unpin>(&mut self, handle: RawPooledMut<P>) -> P {
        self.pool.remove_mut_unpin(handle)
    }

    /// Removes an object from the pool and returns it.
    ///
    /// # Panics
    ///
    /// Panics if the handle does not reference an existing item in this pool.
    ///
    /// Panics if `P` is a type-erased handle (`RawPooled<()>`).
    ///
    /// # Safety
    ///
    /// The caller must ensure that the handle is valid and belongs to this pool.
    pub unsafe fn remove_unpin<P: Unpin>(&mut self, handle: RawPooled<P>) -> P {
        // SAFETY: Forwarding guarantees from caller.
        unsafe { self.pool.remove_unpin(handle) }
    }
}

impl<T> Default for RawPinnedPool<T> {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
#[allow(
    clippy::indexing_slicing,
    reason = "tests focus on succinct code and do not need to tick all the boxes"
)]
mod tests {
    use std::mem::MaybeUninit;

    use super::*;

    // Thread safety static assertions
    use static_assertions::{assert_impl_all, assert_not_impl_any};
    
    assert_impl_all!(RawPinnedPool<u32>: Send);
    assert_not_impl_any!(RawPinnedPool<u32>: Sync);

    #[test]
    fn new_pool_is_empty() {
        let pool = RawPinnedPool::<u64>::new();

        assert_eq!(pool.len(), 0);
        assert!(pool.is_empty());
        assert_eq!(pool.capacity(), 0);
    }

    #[test]
    fn default_pool_is_empty() {
        let pool = RawPinnedPool::<u32>::default();

        assert_eq!(pool.len(), 0);
        assert!(pool.is_empty());
        assert_eq!(pool.capacity(), 0);
    }

    #[test]
    fn with_options_creates_pool() {
        let options = PinnedPoolOptions {
            drop_policy: DropPolicy::MustNotDropItems,
        };
        let pool = RawPinnedPool::<i32>::with_options(options);

        assert_eq!(pool.len(), 0);
        assert!(pool.is_empty());
    }

    #[test]
    fn pinned_pool_options_default() {
        let options = PinnedPoolOptions::default();
        assert_eq!(options.drop_policy, DropPolicy::MayDropItems);
    }

    #[test]
    fn insert_and_length() {
        let mut pool = RawPinnedPool::<u32>::new();

        let _handle1 = pool.insert(42_u32);
        assert_eq!(pool.len(), 1);
        assert!(!pool.is_empty());

        let _handle2 = pool.insert(100_u32);
        assert_eq!(pool.len(), 2);
    }

    #[test]
    fn capacity_grows_with_slabs() {
        let mut pool = RawPinnedPool::<u64>::new();

        assert_eq!(pool.capacity(), 0);

        let _handle = pool.insert(123_u64);

        // Should have at least one slab's worth of capacity now
        assert!(pool.capacity() > 0);
        let initial_capacity = pool.capacity();

        // Fill up the slab to force creation of a new one
        for i in 1..initial_capacity {
            let _handle = pool.insert(i as u64);
        }

        // One more insert should create a new slab
        let _handle = pool.insert(999_u64);

        assert!(pool.capacity() >= initial_capacity * 2);
    }

    #[test]
    fn reserve_creates_capacity() {
        let mut pool = RawPinnedPool::<u8>::new();

        pool.reserve(100);
        assert!(pool.capacity() >= 100);

        let initial_capacity = pool.capacity();
        pool.reserve(50); // Should not increase capacity
        assert_eq!(pool.capacity(), initial_capacity);

        pool.reserve(200); // Should increase capacity
        assert!(pool.capacity() >= 200);
    }

    #[test]
    fn insert_with_closure() {
        let mut pool = RawPinnedPool::<u64>::new();

        let handle = pool.insert_with(|uninit: &mut MaybeUninit<u64>| {
            uninit.write(42);
        });

        assert_eq!(pool.len(), 1);

        let value = pool.remove_mut_unpin(handle);
        assert_eq!(value, 42);
    }

    #[test]
    fn remove_decreases_length() {
        let mut pool = RawPinnedPool::<String>::new();

        let handle1 = pool.insert("hello".to_string());
        let handle2 = pool.insert("world".to_string());

        assert_eq!(pool.len(), 2);

        pool.remove_mut(handle1);
        assert_eq!(pool.len(), 1);

        pool.remove_mut(handle2);
        assert_eq!(pool.len(), 0);
        assert!(pool.is_empty());
    }

    #[test]
    fn remove_unpin_returns_value() {
        let mut pool = RawPinnedPool::<i32>::new();

        let handle = pool.insert(-456_i32);

        let value = pool.remove_mut_unpin(handle);
        assert_eq!(value, -456);
        assert_eq!(pool.len(), 0);
    }

    #[test]
    fn shrink_to_fit_removes_empty_slabs() {
        let mut pool = RawPinnedPool::<u8>::new();

        // Force creation of multiple slabs
        pool.reserve(300);
        let initial_capacity = pool.capacity();

        // Add some items
        let mut handles = Vec::new();
        for i in 0..10 {
            handles.push(pool.insert(u8::try_from(i).unwrap()));
        }

        // Remove all items
        for handle in handles {
            pool.remove_mut(handle);
        }

        assert!(pool.is_empty());

        // Shrink should reduce capacity but may not eliminate all empty slabs
        // (only trailing empty slabs are removed)
        pool.shrink_to_fit();

        // Capacity should be reduced or at least not increased
        assert!(pool.capacity() <= initial_capacity);
    }

    #[test]
    fn handle_provides_access_to_object() {
        let mut pool = RawPinnedPool::<u64>::new();

        let handle = pool.insert(12345_u64);

        // Access the value through the handle's pointer
        let ptr = handle.ptr();
        // SAFETY: Handle is valid and points to a u64
        let value = unsafe { ptr.as_ref() };
        assert_eq!(*value, 12345);
    }

    #[test]
    fn shared_handles_are_copyable() {
        let mut pool = RawPinnedPool::<u32>::new();

        let handle1 = pool.insert(789_u32).into_shared();
        let handle2 = handle1;
        #[expect(clippy::clone_on_copy, reason = "intentional, testing cloning")]
        let handle3 = handle1.clone();

        assert_eq!(handle1, handle2);
        assert_eq!(handle1, handle3);
        assert_eq!(handle2, handle3);
    }

    #[test]
    fn multiple_removals_and_insertions() {
        let mut pool = RawPinnedPool::<usize>::new();

        // Insert, remove, insert again to test slot reuse
        let handle1 = pool.insert(1_usize);
        pool.remove_mut(handle1);

        let handle2 = pool.insert(2_usize);

        assert_eq!(pool.len(), 1);

        let value = pool.remove_mut_unpin(handle2);
        assert_eq!(value, 2);
    }

    #[test]
    fn remove_with_shared_handle() {
        let mut pool = RawPinnedPool::<i64>::new();

        let handle_mut = pool.insert(999_i64);
        let handle_shared = handle_mut.into_shared();

        assert_eq!(pool.len(), 1);

        // SAFETY: Handle is valid and comes from this pool
        unsafe {
            pool.remove(handle_shared);
        }

        assert_eq!(pool.len(), 0);
        assert!(pool.is_empty());
    }

    #[test]
    fn remove_unpin_with_shared_handle() {
        let mut pool = RawPinnedPool::<i32>::new();

        let handle_mut = pool.insert(42_i32);
        let handle_shared = handle_mut.into_shared();

        assert_eq!(pool.len(), 1);

        // SAFETY: Handle is valid and comes from this pool
        let value = unsafe { pool.remove_unpin(handle_shared) };

        assert_eq!(value, 42);
        assert_eq!(pool.len(), 0);
    }

    #[test]
    #[should_panic]
    fn remove_unpin_panics_on_zero_sized_type() {
        // We need to use a type that is not zero-sized for the pool itself,
        // but we create a handle that gets type-erased to a ZST.
        let mut pool = RawPinnedPool::<u8>::new();

        let handle = pool.insert(123_u8);

        let erased_handle: RawPooled<()> = handle.into_shared().erase();

        // This should panic because size_of::<()>() == 0
        // SAFETY: Handle points to valid memory but type is ZST.
        unsafe {
            pool.remove_unpin(erased_handle);
        }
    }

    #[test]
    fn type_erased_handles_work_for_removal() {
        let mut pool = RawPinnedPool::<String>::new();

        let handle = pool.insert("test".to_string());
        let erased_handle: RawPooled<()> = handle.into_shared().erase();

        assert_eq!(pool.len(), 1);

        // Should work with type-erased handles (just drops the value)
        // SAFETY: Handle is valid and comes from this pool
        unsafe {
            pool.remove(erased_handle);
        }

        assert_eq!(pool.len(), 0);
    }

    #[test]
    fn different_handle_types_for_removal() {
        let mut pool = RawPinnedPool::<Vec<i32>>::new();

        let handle_i32: RawPooledMut<Vec<i32>> = pool.insert(vec![1, 2, 3]);

        // Convert to shared handle of different type (conceptually)
        let shared_handle = handle_i32.into_shared();

        assert_eq!(pool.len(), 1);

        // Should work with handles of different generic types  
        // SAFETY: Handle is valid and comes from this pool
        let value: Vec<i32> = unsafe { pool.remove_unpin(shared_handle) };

        assert_eq!(value, vec![1, 2, 3]);
        assert_eq!(pool.len(), 0);
    }
}