//! Provides macro for defining dynamic cast operations on pooled types.
//!
//! The [`define_pooled_dyn_cast!`] macro generates extension traits that allow casting
//! pooled values to trait objects while preserving reference counting semantics.

/// Defines a dynamic cast operation for pooled types.
///
/// This macro generates an extension trait that provides a method to cast a pooled value
/// from an unknown concrete type to a trait object, while preserving the reference counting
/// and pool management semantics.
///
/// The generated cast method allows conversion from `Pooled<T>` to `Pooled<dyn TraitObject>`
/// (and similarly for `LocalPooled` and `RawPooled`) where `T` implements the trait object.
///
/// # Parameters
///
/// - `cast_name`: The identifier used for the cast method name and trait name (converted to
///   appropriate case conventions).
/// - `trait_path`: The trait to cast to (e.g., `Display` or `std::fmt::Display`).
///
/// For traits with associated types or complex bounds, you can specify the full trait bound.
/// For example, `Future<Output = ()>` or `Display + Send`.
///
/// # Generated Items
///
/// For `define_pooled_dyn_cast!(display, Display)`, this macro generates:
///
/// - Trait `PooledCastDisplay` with method `cast_display()`
/// - Implementations for `Pooled<T>`, `LocalPooled<T>`, and `RawPooled<T>`
///
/// # Examples
///
/// Basic trait casting:
///
/// ```rust
/// use blind_pool::{BlindPool, define_pooled_dyn_cast};
/// use std::fmt::Display;
///
/// // Define the cast operation.
/// define_pooled_dyn_cast!(display, Display);
///
/// let pool = BlindPool::new();
/// let pooled = pool.insert(42_u32);
///
/// // Cast to trait object while preserving reference counting.
/// let display_pooled = pooled.cast_display();
///
/// // Can now store in a struct.
/// struct Foo {
///     value: blind_pool::Pooled<dyn Display>,
/// }
///
/// let foo = Foo { value: display_pooled };
/// ```
///
/// Complex trait bounds:
///
/// ```rust
/// use blind_pool::{BlindPool, define_pooled_dyn_cast};
/// use std::future::Future;
///
/// // Define cast for futures with specific output type.
/// define_pooled_dyn_cast!(future_unit, Future<Output = ()>);
///
/// let pool = BlindPool::new();
/// let pooled = pool.insert(async {});
///
/// // Cast to trait object while preserving reference counting.
/// let future_pooled = pooled.cast_future_unit();
///
/// struct TaskManager {
///     tasks: Vec<blind_pool::Pooled<dyn Future<Output = ()>>>,
/// }
/// ```
#[macro_export]
macro_rules! define_pooled_dyn_cast {
    ($cast_name:ident, $trait_path:path) => {
        ::paste::paste! {
            /// Extension trait for casting pooled values to trait objects.
            ///
            /// This trait is generated by the [`define_pooled_dyn_cast!`] macro and provides
            /// a method to cast pooled values to the specified trait object type.
            pub trait [<PooledCast $cast_name:camel>]<T> {
                /// Casts this pooled value to a trait object.
                ///
                /// This method converts a pooled value from an unknown concrete type to a
                /// trait object while preserving the reference counting and pool management
                /// semantics.
                ///
                /// The cast is performed through safe reference coercion - if the concrete
                /// type does not implement the required trait, compilation will fail.
                fn [<cast_ $cast_name>](self) -> Self::Output;

                /// The output type after casting.
                type Output;
            }

            impl<T> [<PooledCast $cast_name:camel>]<T> for $crate::Pooled<T>
            where
                T: $trait_path + 'static,
            {
                type Output = $crate::Pooled<dyn $trait_path>;

                fn [<cast_ $cast_name>](self) -> Self::Output {
                    self.cast_dyn_with_fn(|x| x as &dyn $trait_path)
                }
            }

            impl<T> [<PooledCast $cast_name:camel>]<T> for $crate::LocalPooled<T>
            where
                T: $trait_path + 'static,
            {
                type Output = $crate::LocalPooled<dyn $trait_path>;

                fn [<cast_ $cast_name>](self) -> Self::Output {
                    self.cast_dyn_with_fn(|x| x as &dyn $trait_path)
                }
            }

            impl<T> [<PooledCast $cast_name:camel>]<T> for $crate::RawPooled<T>
            where
                T: $trait_path + 'static,
            {
                type Output = $crate::RawPooled<dyn $trait_path>;

                fn [<cast_ $cast_name>](self) -> Self::Output {
                    self.cast_dyn_with_fn(|x| x as &dyn $trait_path)
                }
            }
        }
    };
}
