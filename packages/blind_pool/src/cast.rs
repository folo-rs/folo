//! Provides macro for defining dynamic cast operations on pooled types.
//!
//! The [`define_pooled_dyn_cast!`] macro generates extension traits that allow casting
//! pooled values to trait objects while preserving reference counting semantics.

/// Defines a dynamic cast operation for pooled types.
///
/// This macro generates an extension trait that provides a method to cast a pooled value
/// from an unknown concrete type to a trait object, while preserving the reference counting
/// and pool management semantics.
///
/// The generated cast method allows conversion from `Pooled<T>` to `Pooled<dyn TraitAlias>`
/// (and similarly for `LocalPooled` and `RawPooled`) where `T` implements the trait alias.
///
/// # Parameters
///
/// - `trait_alias`: The trait alias name (e.g., `Display`, `SendUnitFuture`). The method name
///   is automatically derived by converting this to `snake_case` with a `cast_` prefix.
///
/// For complex trait bounds, define a trait alias first, then use this macro with the alias name.
///
/// # Generated Items
///
/// For `define_pooled_dyn_cast!(Display)`, this macro generates:
///
/// - Trait `PooledCastDisplay` with method `cast_display()`
/// - Implementations for `Pooled<T>`, `LocalPooled<T>`, and `RawPooled<T>`
///
/// # Examples
///
/// Basic trait casting:
///
/// ```rust
/// use std::fmt::Display;
///
/// use blind_pool::{BlindPool, define_pooled_dyn_cast};
///
/// // Define the cast operation.
/// define_pooled_dyn_cast!(Display);
///
/// let pool = BlindPool::new();
/// let pooled = pool.insert(42_u32);
///
/// // Cast to trait object while preserving reference counting.
/// let display_pooled = pooled.cast_display();
///
/// // Can now store in a struct.
/// struct Foo {
///     value: blind_pool::Pooled<dyn Display>,
/// }
///
/// let foo = Foo {
///     value: display_pooled,
/// };
/// ```
///
/// Complex trait bounds using trait aliases:
///
/// ```rust
/// use std::future::Future;
///
/// use blind_pool::{BlindPool, define_pooled_dyn_cast};
///
/// // Define a trait alias for complex bounds.
/// pub trait UnitFuture: Future<Output = ()> + Send {}
/// impl<T> UnitFuture for T where T: Future<Output = ()> + Send {}
///
/// // Define cast using the trait alias.
/// define_pooled_dyn_cast!(UnitFuture);
///
/// let pool = BlindPool::new();
/// let pooled = pool.insert(async {});
///
/// // Cast to trait object (method name derived from trait alias).
/// let future_pooled = pooled.cast_unit_future();
///
/// struct TaskManager {
///     tasks: Vec<blind_pool::Pooled<dyn UnitFuture>>,
/// }
/// ```
#[macro_export]
macro_rules! define_pooled_dyn_cast {
    ($trait_alias:ident) => {
        ::paste::paste! {
            /// Extension trait for casting pooled values to trait objects.
            ///
            /// This trait is generated by the [`define_pooled_dyn_cast!`] macro and provides
            /// a method to cast pooled values to the specified trait object type.
            pub trait [<PooledCast $trait_alias>]<T> {
                /// Casts this pooled value to a trait object.
                ///
                /// This method converts a pooled value from an unknown concrete type to a
                /// trait object while preserving the reference counting and pool management
                /// semantics.
                ///
                /// The cast is performed through safe reference coercion - if the concrete
                /// type does not implement the required trait, compilation will fail.
                fn [<cast_ $trait_alias:snake>](self) -> Self::Output;

                /// The output type after casting.
                type Output;
            }

            impl<T> [<PooledCast $trait_alias>]<T> for $crate::Pooled<T>
            where
                T: $trait_alias + 'static,
            {
                type Output = $crate::Pooled<dyn $trait_alias>;

                fn [<cast_ $trait_alias:snake>](self) -> Self::Output {
                    self.cast_dyn_with_fn(|x| x as &dyn $trait_alias)
                }
            }

            impl<T> [<PooledCast $trait_alias>]<T> for $crate::LocalPooled<T>
            where
                T: $trait_alias + 'static,
            {
                type Output = $crate::LocalPooled<dyn $trait_alias>;

                fn [<cast_ $trait_alias:snake>](self) -> Self::Output {
                    self.cast_dyn_with_fn(|x| x as &dyn $trait_alias)
                }
            }

            impl<T> [<PooledCast $trait_alias>]<T> for $crate::RawPooled<T>
            where
                T: $trait_alias + 'static,
            {
                type Output = $crate::RawPooled<dyn $trait_alias>;

                fn [<cast_ $trait_alias:snake>](self) -> Self::Output {
                    self.cast_dyn_with_fn(|x| x as &dyn $trait_alias)
                }
            }
        }
    };
}
