use std::alloc::Layout;
use std::fmt;
use std::ops::Deref;
use std::pin::Pin;
use std::ptr::NonNull;

use opaque_pool::Pooled as OpaquePooled;

/// A handle representing an item stored in a `RawBlindPool`.
///
/// Acts as a super-powered pointer that can be copied and cloned freely. This provides
/// access to the stored item and can be used to remove the item from the pool.
///
/// Being `Copy` and `Clone`, this type behaves like a regular pointer - you can duplicate
/// handles freely without affecting the underlying stored value. Multiple copies of the same
/// handle all refer to the same stored value.
///
/// # Example
///
/// ```rust
/// use blind_pool::RawBlindPool;
///
/// let mut pool = RawBlindPool::new();
///
/// let pooled = pool.insert("Hello".to_string());
///
/// // The handle acts like a super-powered pointer - it can be copied freely.
/// let pooled_copy = pooled;
/// let pooled_clone = pooled.clone();
///
/// // All copies refer to the same stored value.
/// let value1 = &*pooled; // Safe deref access
/// let value2 = &*pooled_copy; // Safe deref access
/// let value3 = &*pooled_clone; // Safe deref access
/// assert_eq!(value1, "Hello");
/// assert_eq!(value2, "Hello");
/// assert_eq!(value3, "Hello");
///
/// // To remove the item from the pool, any handle can be used.
/// unsafe { pool.remove(&pooled) };
/// ```
///
/// # Thread safety
///
/// This type is thread-safe ([`Send`] + [`Sync`]) if and only if `T` implements [`Sync`].
/// When `T` is [`Sync`], multiple threads can safely share handles to the same data.
/// When `T` is not [`Sync`], the handle is single-threaded and cannot be moved between threads
/// or shared between threads, preventing unsafe access to non-thread-safe data.
pub struct RawPooled<T: ?Sized> {
    /// The memory layout of the stored item. This is used to identify which internal
    /// pool the item belongs to.
    pub(crate) layout: Layout,

    /// The handle from the internal opaque pool.
    pub(crate) inner: OpaquePooled<T>,
}

impl<T: ?Sized> RawPooled<T> {
    /// Returns a pointer to the inserted value.
    ///
    /// This is the only way to access the value stored in the pool. The owner of the handle has
    /// exclusive access to the value and may both read and write and may create both `&` shared
    /// and `&mut` exclusive references to the item.
    ///
    /// # Example
    ///
    /// ```rust
    /// use blind_pool::RawBlindPool;
    ///
    /// let mut pool = RawBlindPool::new();
    ///
    /// let pooled = pool.insert(2.5159_f64);
    ///
    /// // Read data back from the memory.
    /// let value = *pooled; // Safe deref access
    /// assert_eq!(value, 2.5159);
    /// ```
    #[must_use]
    #[inline]
    pub fn ptr(&self) -> NonNull<T> {
        self.inner.ptr()
    }

    /// Erases the type information from this `RawPooled<T>` handle,
    /// returning a `RawPooled<()>`.
    ///
    /// This is useful when you want to store handles of different types in the same collection
    /// or pass them to code that doesn't need to know the specific type.
    ///
    /// The handle remains functionally equivalent and can still be used to remove the item
    /// from the pool and drop it. The only change is the removal of the type information.
    ///
    /// # Example
    ///
    /// ```rust
    /// use blind_pool::RawBlindPool;
    ///
    /// let mut pool = RawBlindPool::new();
    ///
    /// let pooled = pool.insert("Test".to_string());
    ///
    /// // Erase type information.
    /// let erased = pooled.erase();
    ///
    /// // Can still access the value safely.
    /// // SAFETY: We know this contains a String.
    /// let value = unsafe { erased.ptr().cast::<String>().as_ref() };
    /// assert_eq!(value.as_str(), "Test");
    ///
    /// // Can still remove the item.
    /// unsafe { pool.remove(&erased) };
    /// ```
    #[must_use]
    #[inline]
    pub fn erase(self) -> RawPooled<()> {
        RawPooled {
            layout: self.layout,
            inner: self.inner.erase(),
        }
    }

    /// Casts this `RawPooled<T>` to a different type.
    ///
    /// This method allows casting the pooled value to a trait object or other compatible type.
    /// The underlying memory layout and pool management remain unchanged.
    ///
    /// This method is primarily intended for use by the [`define_pooled_dyn_cast!`] macro.
    /// For most use cases, prefer the type-safe cast methods generated by that macro.
    ///
    /// # Safety
    ///
    /// The caller is responsible for ensuring that the handle points to a valid item that
    /// has not been removed from the pool.
    ///
    /// The caller must guarantee that the target object is in a state where it is
    /// valid to create a shared reference to it (i.e. no concurrent `&mut` exclusive
    /// references exist.)
    ///
    /// The caller must guarantee that the callback input and output references
    /// point to the same object.
    ///
    /// # Example
    ///
    /// ```rust
    /// use std::fmt::Display;
    ///
    /// use blind_pool::RawBlindPool;
    ///
    /// let mut pool = RawBlindPool::new();
    /// let value_handle = pool.insert("Test".to_string());
    ///
    /// // Cast to trait object.
    /// let display_handle: blind_pool::RawPooled<dyn Display> =
    ///     unsafe { value_handle.__private_cast_dyn_with_fn(|x| x as &dyn Display) };
    ///
    /// // Can access as Display trait object safely.
    /// let display_ref: &dyn Display = &*display_handle;
    /// assert_eq!(format!("{}", display_ref), "Test");
    /// ```
    #[must_use]
    #[inline]
    #[doc(hidden)]
    pub unsafe fn __private_cast_dyn_with_fn<U: ?Sized, F>(self, cast_fn: F) -> RawPooled<U>
    where
        F: FnOnce(&T) -> &U,
    {
        // SAFETY: Forwarding safety requirements to the caller.
        let inner_pooled_new = unsafe { self.inner.__private_cast_dyn_with_fn(cast_fn) };

        RawPooled {
            layout: self.layout,
            inner: inner_pooled_new,
        }
    }

    /// Converts this raw pooled handle to a trait object using a mutable reference cast.
    ///
    /// This method allows casting from `RawPooled<T>` to `RawPooled<dyn Trait>` where `T`
    /// implements the trait, while maintaining exclusive access semantics. The resulting
    /// handle maintains all the same semantics, but dereferences to the trait object
    /// instead of the concrete type.
    ///
    /// This is intended for use by `PooledMut<T>` and `LocalPooledMut<T>` to maintain
    /// proper borrowing semantics during trait object casting.
    ///
    /// # Safety
    ///
    /// The caller is responsible for ensuring that the raw pooled object
    /// handle points to an item that is still present in the pool.
    ///
    /// The caller must guarantee that the target object is in a state where it is
    /// valid to create an exclusive reference to it (i.e. no concurrent `&` shared
    /// or `&mut` exclusive references exist).
    ///
    /// The caller must guarantee that the callback input and output references
    /// point to the same object.
    #[must_use]
    #[inline]
    #[doc(hidden)]
    pub unsafe fn __private_cast_dyn_with_fn_mut<U: ?Sized, F>(self, cast_fn: F) -> RawPooled<U>
    where
        F: FnOnce(&mut T) -> &mut U,
    {
        // SAFETY: Forwarding safety requirements to the caller.
        let inner_pooled_new = unsafe { self.inner.__private_cast_dyn_with_fn_mut(cast_fn) };

        RawPooled {
            layout: self.layout,
            inner: inner_pooled_new,
        }
    }

    /// Returns a pinned reference to the value stored in the pool.
    ///
    /// Since values in the pool are always pinned (they never move once inserted),
    /// this method provides safe access to `Pin<&T>` without requiring unsafe code.
    ///
    /// # Example
    ///
    /// ```rust
    /// use std::pin::Pin;
    ///
    /// use blind_pool::RawBlindPool;
    ///
    /// let mut pool = RawBlindPool::new();
    /// let handle = unsafe {
    ///     pool.insert_with(|uninit| {
    ///         uninit.write("hello".to_string());
    ///     })
    /// };
    ///
    /// let pinned: Pin<&String> = handle.as_pin();
    /// assert_eq!(pinned.len(), 5);
    /// ```
    #[must_use]
    #[inline]
    pub fn as_pin(&self) -> Pin<&T> {
        self.inner.as_pin()
    }

    /// Returns a reference to the underlying opaque pool handle.
    ///
    /// This method is intended for internal use by the higher-level pooled types
    /// to leverage the new convenience methods (Deref, `as_pin`) in `opaque_pool`.
    #[must_use]
    #[inline]
    pub(crate) fn opaque_handle(&self) -> &OpaquePooled<T> {
        &self.inner
    }
}

impl<T: ?Sized> Deref for RawPooled<T> {
    type Target = T;

    /// Provides direct access to the value stored in the pool.
    ///
    /// This allows the handle to be used as if it were a reference to the stored value.
    /// Since `RawPooled<T>` provides shared access, this returns a shared reference.
    ///
    /// # Example
    ///
    /// ```rust
    /// use blind_pool::RawBlindPool;
    ///
    /// let mut pool = RawBlindPool::new();
    /// let string_handle = unsafe {
    ///     pool.insert_with(|uninit| {
    ///         uninit.write("hello".to_string());
    ///     })
    /// };
    ///
    /// // Access string methods directly.
    /// assert_eq!(string_handle.len(), 5);
    /// assert!(string_handle.starts_with("he"));
    /// ```
    #[inline]
    fn deref(&self) -> &Self::Target {
        // SAFETY: The inner handle is valid and contains initialized memory of type T.
        unsafe { self.inner.ptr().as_ref() }
    }
}

impl<T: ?Sized> Copy for RawPooled<T> {}

impl<T: ?Sized> Clone for RawPooled<T> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<T: ?Sized> fmt::Debug for RawPooled<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RawPooled")
            .field("layout", &self.layout)
            .field("inner", &self.inner)
            .finish()
    }
}

// SAFETY: RawPooled<T> is just a fancy reference, so its thread-safety is entirely driven by the
// underlying type T and the presence of the `Sync` auto trait on it.
unsafe impl<T: ?Sized + Sync> Send for RawPooled<T> {}

// SAFETY: RawPooled<T> is just a fancy reference, so its thread-safety is entirely driven by the
// underlying type T and the presence of the `Sync` auto trait on it.
unsafe impl<T: ?Sized + Sync> Sync for RawPooled<T> {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::RawBlindPool;

    #[test]
    fn ptr_access() {
        let mut pool = RawBlindPool::new();
        let pooled = pool.insert(42_u32);

        let value = *pooled; // Safe deref access
        assert_eq!(value, 42);

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&pooled);
        }
    }

    #[test]
    fn erase_type_information() {
        let mut pool = RawBlindPool::new();

        let pooled = pool.insert(42_u64);
        let erased = pooled.erase();

        // SAFETY: We know this contains a u64.
        let value = unsafe { erased.ptr().cast::<u64>().read() };
        assert_eq!(value, 42);

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&erased);
        }
    }

    #[test]
    fn copy_and_clone() {
        let mut pool = RawBlindPool::new();
        let pooled = pool.insert("Hello".to_string());

        // Test Copy trait
        let copied = pooled;
        #[allow(
            clippy::clone_on_copy,
            reason = "Testing both copy and clone functionality"
        )]
        let cloned = pooled.clone();

        // All handles should work
        let val1 = &*pooled;
        let val2 = &*copied;
        let val3 = &*cloned;

        assert_eq!(val1, "Hello");
        assert_eq!(val2, "Hello");
        assert_eq!(val3, "Hello");

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&pooled);
        }
    }

    #[test]
    fn deref_functionality() {
        let mut pool = RawBlindPool::new();
        let string_handle = pool.insert("Hello".to_string());

        // Test Deref access.
        assert_eq!(string_handle.len(), 5);
        assert!(string_handle.starts_with("He"));
        assert_eq!(&*string_handle, "Hello");

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&string_handle);
        }
    }

    #[test]
    fn deref_coercion_works() {
        // Function that takes &str.
        fn char_count(s: &str) -> usize {
            s.chars().count()
        }

        let mut pool = RawBlindPool::new();
        let string_handle = pool.insert("Hello".to_string());

        // Test String -> &str coercion.
        let s: &str = &string_handle;
        assert_eq!(s, "Hello");

        // Should work via Deref coercion.
        assert_eq!(char_count(&string_handle), 5);

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&string_handle);
        }
    }

    #[test]
    fn pinning_functionality() {
        let mut pool = RawBlindPool::new();

        // Test RawPooled pinning.
        let handle = pool.insert("Hello".to_string());
        let pinned = handle.as_pin();
        assert_eq!(pinned.len(), 5);
        assert_eq!(&**pinned, "Hello");

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&handle);
        }
    }

    #[test]
    fn works_with_different_types() {
        let mut pool = RawBlindPool::new();

        // Test with primitive types
        let int_handle = pool.insert(42_i32);
        let float_handle = pool.insert(2.71_f64); // e approximation

        // Use safe deref access for reading values.
        let int_val = *int_handle;
        let float_val = *float_handle;

        assert_eq!(int_val, 42);
        assert!((float_val - 2.71).abs() < f64::EPSILON);

        // Test with complex types
        let vec_handle = pool.insert(vec![1, 2, 3]);
        let string_handle = pool.insert("Test".to_string());

        let vec_val = &*vec_handle;
        let string_val = &*string_handle;

        assert_eq!(vec_val, &[1, 2, 3]);
        assert_eq!(string_val, "Test");

        // Cleanup
        // SAFETY: All handles were just created and have never been used for removal before.
        unsafe {
            pool.remove(&int_handle);
        }
        // SAFETY: All handles were just created and have never been used for removal before.
        unsafe {
            pool.remove(&float_handle);
        }
        // SAFETY: All handles were just created and have never been used for removal before.
        unsafe {
            pool.remove(&vec_handle);
        }
        // SAFETY: All handles were just created and have never been used for removal before.
        unsafe {
            pool.remove(&string_handle);
        }
    }

    #[test]
    fn debug_impl() {
        let mut pool = RawBlindPool::new();
        let pooled = pool.insert(42_u32);

        let debug_str = format!("{pooled:?}");
        assert!(debug_str.contains("RawPooled"));

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&pooled);
        }
    }

    #[test]
    fn cast_functionality() {
        let mut pool = RawBlindPool::new();
        let pooled = pool.insert(42_u64);

        // SAFETY: The pooled handle is valid and the cast is safe.
        let cast_pooled = unsafe {
            pooled.__private_cast_dyn_with_fn(|x: &u64| {
                let display_ref: &dyn fmt::Display = x;
                display_ref
            })
        };

        // The cast should work - we can test Display formatting
        let display_ref = &*cast_pooled;
        assert_eq!(format!("{display_ref}"), "42");

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&pooled);
        }
    }

    #[test]
    fn multiple_handles_to_same_value() {
        let mut pool = RawBlindPool::new();
        let handle1 = pool.insert("Shared".to_string());
        let handle2 = handle1; // Copy the handle

        // Both handles should access the same memory
        let val1 = &*handle1;
        let val2 = &*handle2;

        assert_eq!(val1, "Shared");
        assert_eq!(val2, "Shared");
        assert_eq!(handle1.ptr(), handle2.ptr()); // Same pointer

        // SAFETY: This pooled handle was just created and has never been used for removal before.
        unsafe {
            pool.remove(&handle1);
        }
    }

    #[cfg(test)]
    mod static_assertions {
        use std::cell::RefCell;
        use std::marker::PhantomPinned;
        use std::rc::Rc;

        use static_assertions::{assert_impl_all, assert_not_impl_any};

        use super::RawPooled;

        #[test]
        fn thread_safety_assertions() {
            // RawPooled<T> should be Send+Sync if T is Send+Sync
            assert_impl_all!(RawPooled<u32>: Send, Sync); // u32 is Send+Sync
            assert_impl_all!(RawPooled<String>: Send, Sync); // String is Send+Sync
            assert_impl_all!(RawPooled<Vec<u8>>: Send, Sync); // Vec<u8> is Send+Sync

            // RawPooled<T> should be single-threaded when T is not Send or not Sync
            assert_not_impl_any!(RawPooled<Rc<u32>>: Send, Sync); // Rc is not Send
            assert_not_impl_any!(RawPooled<RefCell<u32>>: Send, Sync); // RefCell is not Sync

            // Type-erased handles should be Send and Sync (() is Send+Sync)
            assert_impl_all!(RawPooled<()>: Send, Sync);
        }

        #[test]
        fn pin_assertions() {
            // RawPooled<T> should always be Unpin regardless of T
            assert_impl_all!(RawPooled<u32>: Unpin);
            assert_impl_all!(RawPooled<String>: Unpin);
            assert_impl_all!(RawPooled<Vec<u8>>: Unpin);
            assert_impl_all!(RawPooled<Rc<u32>>: Unpin);
            assert_impl_all!(RawPooled<RefCell<u32>>: Unpin);
            assert_impl_all!(RawPooled<()>: Unpin);

            // Even with non-Unpin types, RawPooled should still be Unpin
            assert_impl_all!(RawPooled<PhantomPinned>: Unpin);
        }

        #[test]
        fn copy_clone_assertions() {
            // RawPooled should always be Copy and Clone
            assert_impl_all!(RawPooled<u32>: Copy, Clone);
            assert_impl_all!(RawPooled<String>: Copy, Clone);
            assert_impl_all!(RawPooled<Vec<u8>>: Copy, Clone);
            assert_impl_all!(RawPooled<()>: Copy, Clone);
        }
    }
}
